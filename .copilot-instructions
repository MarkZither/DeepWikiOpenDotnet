# GitHub Copilot Instructions for DeepWiki Project

**Always follow these instructions for any code generation or modification in this repository.**

---

## Critical Architecture Rules - MUST ALWAYS APPLY

### 1. Database Migrations - TOOL-GENERATED ONLY
- **RULE**: Migrations are ALWAYS generated by `dotnet ef migrations add` command
- **NEVER** create migration .cs files manually
- **NEVER** write SQL by hand in migration files
- Each provider project MUST have `IDesignTimeDbContextFactory<T>` implementation
- After modifying entity configuration, run: `dotnet ef migrations add [DescriptiveName] -p src/DeepWiki.Data.[Provider]`
- Reference: [ARCHITECTURE_CONSTITUTION.md](./ARCHITECTURE_CONSTITUTION.md#migration-workflow---required-process)

### 2. Database-Agnostic Model Layer
- `DocumentEntity` uses `ReadOnlyMemory<float>` for embeddings (NOT `float[]`, NOT database-specific types)
- Rationale: Zero-allocation, performance, cross-database compatibility
- Type mapping flow:
  ```
  Model: ReadOnlyMemory<float> (database-agnostic)
    ↓ ValueConverter in Configuration
  Provider: SqlVector<float> or pgvector.Vector (provider-specific)
    ↓ Column type
  Database: vector(1536) (SQL Server or PostgreSQL)
  ```

### 3. Entity Framework Core - MANDATORY
- ALL database operations use EF Core 10.x
- NO manual ADO.NET
- NO raw SQL in repositories (use LINQ queries)
- Repositories implement `IDocumentRepository` or `IVectorStore` interfaces
- Use value converters for type mapping between model and database

### 4. Code Organization
- Shared models/interfaces: `src/DeepWiki.Data/`
- SQL Server implementation: `src/DeepWiki.Data.SqlServer/`
  - Configuration/ (entity mapping, vector indexes)
  - DbContexts/ (DbContext + Factory)
  - Repositories/ (CRUD and vector search)
  - Health/ (version validation)
  - Migrations/ (EF tool-generated only)
- PostgreSQL implementation: `src/DeepWiki.Data.Postgres/` (same structure)
- Tests use Testcontainers for real database testing

### 5. Vector Search Implementation
- All implementations use `ReadOnlyMemory<float>` in public interfaces
- `IVectorStore.QueryNearestAsync(ReadOnlyMemory<float> queryEmbedding, ...)`
- Vector dimension validation: ALWAYS 1536
- Indexes: HNSW with m=16, ef_construction=200

---

## When Implementing New Features

### Adding a Property to DocumentEntity
1. ✅ Modify `src/DeepWiki.Data/Entities/DocumentEntity.cs`
2. ✅ Update entity configuration if needed (column type, validation, etc.)
3. ✅ Run: `dotnet ef migrations add [DescriptiveName] -p src/DeepWiki.Data.SqlServer`
4. ✅ Run: `dotnet ef migrations add [DescriptiveName] -p src/DeepWiki.Data.Postgres`
5. ✅ Review generated migration files (read-only, never edit manually)
6. ✅ Update tests if needed
7. ✅ Commit

### Adding a Vector Index
1. ✅ Modify `DocumentEntityConfiguration.cs`
   ```csharp
   builder.HasIndex(d => d.Embedding)
       .HasDatabaseName("IX_Documents_Embedding_HNSW")
       .HasAnnotation("SqlServer:IndexMethod", "HNSW");
   ```
2. ✅ Run migration command (EF generates SQL automatically)
3. ✅ Test on real database (Testcontainers)
4. ✅ Commit

### Creating a New Repository Method
1. ✅ Add method signature to interface (`IDocumentRepository` or `IVectorStore`)
2. ✅ Implement in SQL Server provider (`SqlServerDocumentRepository.cs`)
3. ✅ Implement in PostgreSQL provider (when Phase 1.3 starts)
4. ✅ Add integration tests using Testcontainers
5. ✅ Test passes on BOTH providers before committing

---

## Code Review Checklist

Before suggesting changes, verify:
- [ ] EF Core used, not manual SQL
- [ ] Migrations generated by tool, not created manually
- [ ] No database-specific types in `DocumentEntity`
- [ ] `ReadOnlyMemory<float>` used for embeddings, not `float[]` or provider types
- [ ] Value converters configured for type mapping
- [ ] Integration tests use Testcontainers (real database)
- [ ] Same implementation exists for SQL Server and PostgreSQL
- [ ] Unit tests for models, integration tests for database operations
- [ ] No null reference warnings (explicit validation)
- [ ] Connection strings in configuration, not hardcoded

---

## Prohibited Patterns

```csharp
❌ // Manual migration files
public partial class InitialCreate : Migration {
    protected override void Up(MigrationBuilder migrationBuilder) {
        // DO NOT WRITE SQL HERE MANUALLY
    }
}

❌ // Database-specific types in model
public class DocumentEntity {
    public SqlVector<float> Embedding { get; set; } // WRONG - use ReadOnlyMemory<float>
}

❌ // Raw SQL in repositories
var result = _context.Database.SqlQuery<DocumentEntity>($"SELECT * FROM Documents WHERE ...");

❌ // float[] for embeddings (heap allocation)
public ReadOnlyMemory<float> embedding = new float[1536]; // WRONG - still allocates

❌ // Manual type conversion outside value converter
var sqlVector = new SqlVector<float>(embedding.ToArray()); // Do NOT do this in business logic
```

---

## Approved Patterns

```csharp
✅ // Generated migration (auto-created by EF tool)
public partial class AddVectorIndex : Migration {
    protected override void Up(MigrationBuilder migrationBuilder) {
        // Auto-generated SQL - DO NOT MODIFY
    }
}

✅ // Database-agnostic model
public class DocumentEntity {
    public ReadOnlyMemory<float>? Embedding { get; set; } // Agnostic type
}

✅ // LINQ queries in repositories
var results = await _context.Documents
    .Where(d => d.RepoUrl == repoUrl)
    .OrderBy(d => d.CreatedAt)
    .ToListAsync();

✅ // Value converter in configuration
builder.Property(d => d.Embedding)
    .HasColumnType("vector(1536)")
    .HasConversion(
        v => v.HasValue ? v.Value.ToArray() : null,
        v => v == null ? null : new ReadOnlyMemory<float>(v));

✅ // Testcontainers for integration testing
var fixture = new SqlServerFixture();
await fixture.InitializeAsync();
var context = fixture.CreateDbContext();
```

---

## Performance Considerations

- Use `ReadOnlyMemory<float>` for zero-allocation embeddings
- Use `Span<float>` in calculations for zero-copy memory access
- Batch operations for bulk inserts/updates
- Vector indexes (HNSW) for sub-500ms queries @ 10K docs
- Lazy loading / explicit includes for large result sets
- Pagination with skip/take parameters

---

## Testing Expectations

- **Unit Tests**: Entity validation, serialization (DeepWiki.Data.Tests)
- **Integration Tests**: Database operations with Testcontainers (DeepWiki.Data.SqlServer.Tests, DeepWiki.Data.Postgres.Tests)
- **All tests must pass** before code review
- **90%+ code coverage** on data access layer
- **Same test suite** for both SQL Server and PostgreSQL providers

---

## Questions to Ask Before Coding

1. Is this database-agnostic or provider-specific?
2. Should this use `ReadOnlyMemory<float>` or provider-specific type?
3. Does this require a migration? If yes, is it generated by EF tool?
4. Do both SQL Server and PostgreSQL need implementations?
5. Is there an integration test with real database?

---

**Document Version**: 1.0  
**Last Updated**: 2026-01-17  
**Status**: Active - Required for all code changes to DeepWiki.Data*
