# Data Model: Vector Store Service Layer

**Purpose**: Document the data model for document storage, including entity schemas, metadata format, and EF Core mapping.

---

## Overview

The Vector Store Service uses a single primary entity (`DocumentEntity`) stored in SQL Server 2025 with a `vector(1536)` column for embeddings. Documents are uniquely identified by `(RepoUrl, FilePath)` combination.

---

## Entity Schema

### DocumentEntity (Database)

SQL Server table definition:

```sql
CREATE TABLE Documents (
    -- Primary Key
    Id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    
    -- Uniqueness Key (composite)
    RepoUrl NVARCHAR(500) NOT NULL,
    FilePath NVARCHAR(500) NOT NULL,
    
    -- Content
    Title NVARCHAR(500) NULL,
    [Text] NVARCHAR(MAX) NOT NULL,
    
    -- Embedding (SQL Server 2025 vector type)
    Embedding VECTOR(1536) NOT NULL,
    
    -- Metadata
    MetadataJson NVARCHAR(MAX) NOT NULL DEFAULT '{}',
    TokenCount INT NOT NULL DEFAULT 0,
    FileType NVARCHAR(50) NULL,
    IsCode BIT NOT NULL DEFAULT 0,
    IsImplementation BIT NOT NULL DEFAULT 0,
    
    -- Timestamps
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    UpdatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    
    -- Constraints
    CONSTRAINT UQ_Documents_RepoUrl_FilePath UNIQUE (RepoUrl, FilePath)
);

-- Index for vector similarity search
CREATE INDEX IX_Documents_Embedding ON Documents(Embedding);

-- Index for metadata filtering
CREATE INDEX IX_Documents_RepoUrl ON Documents(RepoUrl);
CREATE INDEX IX_Documents_FileType ON Documents(FileType);
```

### DocumentDto (Application)

C# data transfer object:

```csharp
public class DocumentDto
{
    /// <summary>
    /// Unique identifier for the document.
    /// Auto-generated if empty on insert.
    /// </summary>
    public Guid Id { get; set; }
    
    /// <summary>
    /// Repository URL (e.g., "https://github.com/user/repo").
    /// Part of uniqueness key with FilePath.
    /// </summary>
    public string RepoUrl { get; set; } = string.Empty;
    
    /// <summary>
    /// File path within the repository (e.g., "docs/architecture.md").
    /// Part of uniqueness key with RepoUrl.
    /// </summary>
    public string FilePath { get; set; } = string.Empty;
    
    /// <summary>
    /// Document title. Defaults to filename if not provided.
    /// </summary>
    public string Title { get; set; } = string.Empty;
    
    /// <summary>
    /// Full text content of the document.
    /// </summary>
    public string Text { get; set; } = string.Empty;
    
    /// <summary>
    /// Embedding vector (1536 dimensions).
    /// Generated by IEmbeddingService.
    /// </summary>
    public float[] Embedding { get; set; } = Array.Empty<float>();
    
    /// <summary>
    /// JSON-serialized metadata. See Metadata Format section.
    /// </summary>
    public string MetadataJson { get; set; } = "{}";
    
    /// <summary>
    /// When the document was first created.
    /// </summary>
    public DateTime CreatedAt { get; set; }
    
    /// <summary>
    /// When the document was last updated.
    /// </summary>
    public DateTime UpdatedAt { get; set; }
    
    /// <summary>
    /// Number of tokens in the document text.
    /// </summary>
    public int TokenCount { get; set; }
    
    /// <summary>
    /// File type (e.g., "markdown", "csharp", "python").
    /// Auto-detected from file extension.
    /// </summary>
    public string FileType { get; set; } = string.Empty;
    
    /// <summary>
    /// Whether this document contains code.
    /// </summary>
    public bool IsCode { get; set; }
    
    /// <summary>
    /// Whether this is an implementation file (vs. interface/spec).
    /// </summary>
    public bool IsImplementation { get; set; }
}
```

---

## Metadata Format

The `MetadataJson` column stores additional document metadata as JSON:

### Standard Metadata Fields

```json
{
    "language": "en",
    "file_type": "markdown",
    "chunk_index": 0,
    "chunk_count": 3,
    "parent_id": "00000000-0000-0000-0000-000000000000",
    "source": "github",
    "branch": "main",
    "commit_sha": "abc123",
    "last_modified": "2026-01-18T12:00:00Z",
    "author": "user@example.com",
    "tags": ["documentation", "architecture"],
    "custom_field": "custom_value"
}
```

### Metadata Field Definitions

| Field | Type | Description |
|-------|------|-------------|
| `language` | string | Language code (e.g., "en", "code", "python") |
| `file_type` | string | File type (markdown, csharp, python, etc.) |
| `chunk_index` | int | Zero-based index if document was chunked |
| `chunk_count` | int | Total chunks from parent document |
| `parent_id` | Guid | ID of parent document if this is a chunk |
| `source` | string | Source system (github, gitlab, local) |
| `branch` | string | Git branch name |
| `commit_sha` | string | Git commit SHA |
| `last_modified` | DateTime | Last modification timestamp from source |
| `author` | string | Document author |
| `tags` | string[] | Searchable tags |

### Accessing Metadata

```csharp
using System.Text.Json;

// Read metadata
var metadata = JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(
    document.MetadataJson);

var language = metadata.TryGetValue("language", out var lang) 
    ? lang.GetString() 
    : "en";

// Write metadata
document.MetadataJson = JsonSerializer.Serialize(new
{
    language = "en",
    file_type = "markdown",
    chunk_index = 0
});
```

---

## EF Core Mapping

### DbContext Configuration

```csharp
public class VectorDbContext : DbContext
{
    public DbSet<DocumentEntity> Documents { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<DocumentEntity>(entity =>
        {
            // Table name
            entity.ToTable("Documents");
            
            // Primary key
            entity.HasKey(e => e.Id);
            
            // Uniqueness constraint
            entity.HasIndex(e => new { e.RepoUrl, e.FilePath })
                .IsUnique()
                .HasDatabaseName("UQ_Documents_RepoUrl_FilePath");
            
            // Property configurations
            entity.Property(e => e.RepoUrl)
                .IsRequired()
                .HasMaxLength(500);
            
            entity.Property(e => e.FilePath)
                .IsRequired()
                .HasMaxLength(500);
            
            entity.Property(e => e.Title)
                .HasMaxLength(500);
            
            entity.Property(e => e.Text)
                .IsRequired();
            
            entity.Property(e => e.MetadataJson)
                .IsRequired()
                .HasDefaultValue("{}");
            
            entity.Property(e => e.FileType)
                .HasMaxLength(50);
            
            // Timestamps with defaults
            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("GETUTCDATE()");
            
            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("GETUTCDATE()");
            
            // Vector column (SQL Server 2025)
            entity.Property(e => e.Embedding)
                .HasColumnType("vector(1536)");
            
            // Indexes
            entity.HasIndex(e => e.RepoUrl)
                .HasDatabaseName("IX_Documents_RepoUrl");
            
            entity.HasIndex(e => e.FileType)
                .HasDatabaseName("IX_Documents_FileType");
        });
    }
}
```

### DocumentEntity (EF Core)

```csharp
public class DocumentEntity
{
    public Guid Id { get; set; }
    public string RepoUrl { get; set; } = string.Empty;
    public string FilePath { get; set; } = string.Empty;
    public string? Title { get; set; }
    public string Text { get; set; } = string.Empty;
    public float[] Embedding { get; set; } = Array.Empty<float>();
    public string MetadataJson { get; set; } = "{}";
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public int TokenCount { get; set; }
    public string? FileType { get; set; }
    public bool IsCode { get; set; }
    public bool IsImplementation { get; set; }
}
```

### Value Conversion for Embedding

SQL Server 2025's `vector(1536)` type may require custom conversion:

```csharp
// Custom value converter for vector type (if needed)
public class VectorConverter : ValueConverter<float[], byte[]>
{
    public VectorConverter() : base(
        v => VectorToBytes(v),
        b => BytesToVector(b))
    { }
    
    private static byte[] VectorToBytes(float[] vector)
    {
        var bytes = new byte[vector.Length * sizeof(float)];
        Buffer.BlockCopy(vector, 0, bytes, 0, bytes.Length);
        return bytes;
    }
    
    private static float[] BytesToVector(byte[] bytes)
    {
        var vector = new float[bytes.Length / sizeof(float)];
        Buffer.BlockCopy(bytes, 0, vector, 0, bytes.Length);
        return vector;
    }
}

// Apply in configuration
entity.Property(e => e.Embedding)
    .HasConversion<VectorConverter>();
```

---

## Query Models

### VectorQueryResult

Result from similarity search:

```csharp
public class VectorQueryResult
{
    /// <summary>
    /// The retrieved document.
    /// </summary>
    public DocumentDto Document { get; set; } = new();
    
    /// <summary>
    /// Cosine similarity score (0.0 to 1.0, higher = more similar).
    /// </summary>
    public float SimilarityScore { get; set; }
}
```

### TextChunk

Result from document chunking:

```csharp
public sealed class TextChunk
{
    public string Text { get; init; } = string.Empty;
    public int ChunkIndex { get; init; }
    public Guid? ParentId { get; init; }
    public int TokenCount { get; init; }
    public string Language { get; init; } = "en";
    public int StartOffset { get; init; }
    public int Length { get; init; }
}
```

---

## Ingestion Models

### IngestionDocument

Input document for ingestion:

```csharp
public sealed class IngestionDocument
{
    public string RepoUrl { get; init; } = string.Empty;
    public string FilePath { get; init; } = string.Empty;
    public string Text { get; init; } = string.Empty;
    public string? Title { get; init; }
    public Dictionary<string, string>? Metadata { get; init; }
}
```

### IngestionRequest

Batch ingestion request:

```csharp
public sealed class IngestionRequest
{
    public IReadOnlyList<IngestionDocument> Documents { get; init; } = [];
    public int BatchSize { get; init; } = 10;
    public int MaxRetries { get; init; } = 3;
    public int MaxTokensPerChunk { get; init; } = 8192;
    public bool ContinueOnError { get; init; } = true;
    public bool SkipEmbedding { get; init; }
    public Dictionary<string, string>? MetadataDefaults { get; init; }
}
```

### IngestionResult

Batch ingestion result:

```csharp
public sealed class IngestionResult
{
    public int SuccessCount { get; init; }
    public int FailureCount { get; init; }
    public int TotalChunks { get; init; }
    public IReadOnlyList<IngestionError> Errors { get; init; } = [];
    public long DurationMs { get; init; }
    public IReadOnlyList<Guid> IngestedDocumentIds { get; init; } = [];
}
```

---

## Relationships

```
┌─────────────────────────────────────────────────────┐
│                    DocumentDto                       │
│  (Primary document or chunk)                         │
├─────────────────────────────────────────────────────┤
│  Id: Guid (PK)                                      │
│  RepoUrl + FilePath: UNIQUE                         │
│  Embedding: vector(1536)                            │
│  MetadataJson: { parent_id, chunk_index, ... }      │
└─────────────────────────────────────────────────────┘
        │
        │ (via MetadataJson.parent_id)
        ▼
┌─────────────────────────────────────────────────────┐
│              Parent Document (if chunked)            │
│  Same table, linked by parent_id in metadata        │
└─────────────────────────────────────────────────────┘
```

**Note**: Chunks are stored as separate documents with `parent_id` in metadata. This enables:
- Individual chunk retrieval
- Chunk-level similarity scores
- Reconstruction of parent document if needed

---

## File Type Detection

File types are auto-detected from file extension:

```csharp
public static class FileTypeDetector
{
    public static string DetectFileType(string filePath)
    {
        var extension = Path.GetExtension(filePath).ToLowerInvariant();
        return extension switch
        {
            ".md" or ".markdown" => "markdown",
            ".cs" => "csharp",
            ".py" => "python",
            ".js" => "javascript",
            ".ts" => "typescript",
            ".json" => "json",
            ".yaml" or ".yml" => "yaml",
            ".xml" => "xml",
            ".html" or ".htm" => "html",
            ".css" => "css",
            ".sql" => "sql",
            ".sh" or ".bash" => "shell",
            ".ps1" => "powershell",
            ".java" => "java",
            ".go" => "go",
            ".rs" => "rust",
            ".rb" => "ruby",
            ".php" => "php",
            ".txt" => "text",
            _ => "unknown"
        };
    }
    
    public static bool IsCodeFile(string fileType)
    {
        return fileType is "csharp" or "python" or "javascript" or "typescript" 
            or "java" or "go" or "rust" or "ruby" or "php" or "shell" 
            or "powershell" or "sql";
    }
}
```

---

## Migration Example

EF Core migration for creating the Documents table:

```csharp
public partial class CreateDocumentsTable : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "Documents",
            columns: table => new
            {
                Id = table.Column<Guid>(nullable: false, defaultValueSql: "NEWID()"),
                RepoUrl = table.Column<string>(maxLength: 500, nullable: false),
                FilePath = table.Column<string>(maxLength: 500, nullable: false),
                Title = table.Column<string>(maxLength: 500, nullable: true),
                Text = table.Column<string>(nullable: false),
                Embedding = table.Column<byte[]>(type: "vector(1536)", nullable: false),
                MetadataJson = table.Column<string>(nullable: false, defaultValue: "{}"),
                TokenCount = table.Column<int>(nullable: false, defaultValue: 0),
                FileType = table.Column<string>(maxLength: 50, nullable: true),
                IsCode = table.Column<bool>(nullable: false, defaultValue: false),
                IsImplementation = table.Column<bool>(nullable: false, defaultValue: false),
                CreatedAt = table.Column<DateTime>(nullable: false, defaultValueSql: "GETUTCDATE()"),
                UpdatedAt = table.Column<DateTime>(nullable: false, defaultValueSql: "GETUTCDATE()")
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_Documents", x => x.Id);
            });

        migrationBuilder.CreateIndex(
            name: "UQ_Documents_RepoUrl_FilePath",
            table: "Documents",
            columns: new[] { "RepoUrl", "FilePath" },
            unique: true);

        migrationBuilder.CreateIndex(
            name: "IX_Documents_RepoUrl",
            table: "Documents",
            column: "RepoUrl");

        migrationBuilder.CreateIndex(
            name: "IX_Documents_FileType",
            table: "Documents",
            column: "FileType");
    }

    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(name: "Documents");
    }
}
```

---

## See Also

- [IVectorStore](./contracts/IVectorStore.md) - Vector store interface
- [IDocumentIngestionService](./contracts/IDocumentIngestionService.md) - Ingestion operations
- [quickstart.md](./quickstart.md) - Usage examples
