@page "/chat"
@using deepwiki_open_dotnet.Web.Models
@using deepwiki_open_dotnet.Web.Services
@using deepwiki_open_dotnet.Web.Components.Shared
@using MudBlazor
@inject ChatStateService ChatState
@inject ChatApiClient ChatApi
@inject NdJsonStreamParser Parser
@inject IJSRuntime JS
@inject Markdig.MarkdownPipeline MarkdownPipeline
@inject IDialogService DialogService

<div class="chat-page">
    <div class="chat-header d-flex align-items-center mb-2">
        <h5 class="me-auto">Chat</h5>
        @if (ChatState.IsGenerating)
        {
            <MudProgressLinear Indeterminate="true" Color="Color.Secondary" Class="w-25" />
        }
        <MudIconButton id="clear-chat-btn"
                       Icon="@Icons.Material.Filled.DeleteSweep"
                       title="Clear chat history"
                       Size="Size.Small"
                       Color="Color.Default"
                       Disabled="ChatState.IsGenerating"
                       OnClick="ConfirmClearAsync" />
    </div>

    <div class="message-list" style="max-height:60vh; overflow:auto;" id="message-list">
        @foreach (var m in ChatState.Messages)
        {
            <ChatMessage Message="m" />
        }
    </div>

    <div class="mt-3">
        <DocumentScopeSelector />

        <div class="scope-indicator my-2 d-flex align-items-center">
            <MudIcon Icon="@Icons.Material.Filled.Search" Size="Size.Small" Class="me-1 text-muted" />
            <span class="small text-muted">Searching: <strong>@ChatState.ScopeLabel</strong></span>
        </div>
        <ChatInput OnSubmit="HandleSubmit" />
    </div>
</div>

@code {
    private Guid _sessionId = Guid.Empty;

    protected override async Task OnInitializedAsync()
    {
        ChatState.StateChanged += OnStateChanged;
        
        // Create a session for this chat
        var sessionReq = new SessionRequestDto { Owner = "web-user" };
        var sessionResp = await ChatApi.CreateSessionAsync(sessionReq);
        _sessionId = sessionResp.SessionId;
    }

    private void OnStateChanged() => InvokeAsync(StateHasChanged);

    public void Dispose()
    {
        ChatState.StateChanged -= OnStateChanged;
    }

    private async Task HandleSubmit(string userInput)
    {
        // Add user message
        ChatState.AddMessage(new ChatMessageModel { Role = MessageRole.User, Text = userInput });

        // Add assistant placeholder
        ChatState.AddMessage(new ChatMessageModel { Role = MessageRole.Assistant, Text = string.Empty, IsStreaming = true });

        ChatState.IsGenerating = true;
        var cts = new CancellationTokenSource();

        try
        {
            var collectionIds = ChatState.SelectedCollectionIds.Count > 0
                ? new System.Collections.Generic.List<string>(ChatState.SelectedCollectionIds)
                : null;

            var request = new GenerationRequestDto
            {
                SessionId = _sessionId,
                Prompt = userInput,
                CollectionIds = collectionIds
            };

            var resp = await ChatApi.StreamGenerationAsync(request, cts.Token).ConfigureAwait(false);
            if (!resp.IsSuccessStatusCode)
            {
                var err = $"API returned {(int)resp.StatusCode} {resp.ReasonPhrase}";
                UpdateLastWithError(err);
                return;
            }

            await using var stream = await resp.Content.ReadAsStreamAsync(cts.Token).ConfigureAwait(false);

            await foreach (var delta in Parser.ParseAsync(stream, cts.Token))
            {
                if (!string.IsNullOrEmpty(delta.Text))
                {
                    ChatState.UpdateLastMessage(m => m.Text += delta.Text);
                    // scroll to latest
                    var last = ChatState.Messages.LastOrDefault();
                    if (last is not null)
                        await JS.InvokeVoidAsync("chat.scrollIntoViewById", $"message-{last.Id}");
                }

                if (delta.Type == "error")
                {
                    UpdateLastWithError(delta.Error ?? "Unknown error");
                    // inline error shown on message; no global toast in tests
                    break;
                }

                if (delta.Done == true)
                {
                    ChatState.UpdateLastMessage(m => m.IsStreaming = false);

                    var sources = NdJsonStreamParser.MapToSourceCitations(delta.Metadata?.Sources);
                    if (sources.Count > 0)
                        ChatState.UpdateLastMessage(m => { m.Sources.AddRange(sources); });

                    break;
                }
            }
        }
        catch (OperationCanceledException)
        {
            UpdateLastWithError("Generation canceled");
        }
        catch (Exception ex)
        {
            UpdateLastWithError(ex.Message);
        }
        finally
        {
            ChatState.IsGenerating = false;
        }
    }

    private async Task ConfirmClearAsync()
    {
        bool? confirmed = await DialogService.ShowMessageBox(
            "Clear chat history",
            "This will remove all messages. Your collection selection will be kept.",
            yesText: "Clear",
            cancelText: "Cancel");

        if (confirmed == true)
        {
            ChatState.ClearMessages();
        }
    }

    private void UpdateLastWithError(string msg)
    {
        ChatState.UpdateLastMessage(m => { m.IsStreaming = false; m.ErrorMessage = msg; });
    }
}
